'''
Проверить гипотезу о быстром поэлементном объединении двух отсортированных массивов.

На входе подается два рандромно заполненных и отсортированных массива

На выходе должен получиться один отсортированный массив
'''

from timeit import timeit
import random


def quick_merge(list1, list2):
    """
    Функция принимает на вход два отсортированных массива и поэлементно их объединяет.
    :param list1:
    :param list2:
    :return: 
    """
    result = []
    p1 = 0          # создаем численные указатели для начала списков
    p2 = 0  
    while p1 < len(list1) and p2 < len(list2):  # проверка не закончился ли список
        if list1[p1] <= list2[p2]: # ищем меньший элемент
            result.append(list1[p1]) # и добавляем его в новый список
            p1 += 1 # увеличиваем указатель на первый элемент
        else:
            result.append(list2[p2])
            p2 += 1
    if p1 < len(list1): # когда один из список закончился, 
        result += list1[p1:] # добавляем оставшиеся элементы другого списка
    if p2 < len(list2):
        result += list2[p2:]    
    return result


def merge(list1, list2):
    return sorted(list1 + list2)


def new_merge(list1, list2):
    res = list1 + list2
    res.sort()
    return res


numbers1 = sorted([random.randint(1, 2000000) for _ in range(1000000)])
numbers2 = sorted([random.randint(1, 2000000) for _ in range(2000000)])

quick_merge(numbers1, numbers2)
print(f'Время выполнения quick_merge: '
      f'{timeit("quick_merge(numbers1, numbers2)", globals=globals(), number=100)}')
# 153.48526719998335


merge(numbers1, numbers2)
print(f'Время выполнения merge: '
      f'{timeit("merge(numbers1, numbers2)", globals=globals(), number=100)}')
# 52.15125719999196

new_merge(numbers1, numbers2)
print(f'Время выполнения new_merge: '
      f'{timeit("new_merge(numbers1, numbers2)", globals=globals(), number=100)}')
# 40.89479419999407


"""
На вход программа принимает два рандромно заполненных отсортированных списка с 
разным количеством элементов (в первом - 100тысяч, во втором - 200).

1) Функция quick_merge() выполняет заполнение результирующего массива 
элементами по порядку следования, начиная с меньшего.
Время выполнения: 161.67388699998264

2) Во втором способе применяется сложение двух массивов и сортировка 
полученного массива методом sord().
Время выполнения: 56.95908769997186 - почти в 3 раза быстрее, 
чем предыдущая функция

3) В третьем спсособе применяется функция sorted() к результату сложения 
двух исходных массивов.
Время выполнения: 50.49216179997893 - почти на 10% быстрее, чем метод sort()

Вывод: использование стандартных методов и функций значительно ускоряет 
время работы программы
"""
